---
title: "RQ5: weighting"
format: 
  html:
    embed-resources: true
    fig-width: 8
    fig-height: 8
    code-link: true
    code-fold: true
    code-tools: true
    df-print: paged
    toc: true
    grid:
      body-width: 900px
editor: source
---

# To do 

trim weights

# Load data


```{r}
#| output: false

source("0_load_data.R")

```

## Weight calculation 

We are going to calculate weights for each pairwise missingness category. 

First we need to define each missingness outcome: 

```{r}


# Create matrix positions for correlation plot (adapted from RQ2)
test_correlation_matrix = matrix(
  nrow = length(rq5y),
  ncol = length(rq5y)
)

for(i in seq_along(rq5y)){
  for(j in seq_along(rq5y)){
    test_correlation_matrix[i,j] = paste(rq5y[i], rq5y[j], sep = "-")
  }
}

vars = test_correlation_matrix[lower.tri(test_correlation_matrix, diag = TRUE)]

  x_var = str_extract(vars, "^[^-]+")
  y_var = str_extract(vars, "[^-]+$")
  missingcode = paste0("missing",1:length(vars))


rm(test_correlation_matrix)

# Create columns to see if data is pairwise missing (0) or not (1)

for(i in seq_along(vars)){
  df[[missingcode[i]]] = !is.na(df[[x_var[i]]]) | !is.na(df[[y_var[i]]]) 
  df[[missingcode[i]]] = factor(as.numeric(df[[missingcode[i]]]))

}

x = df %>%
  select(starts_with("missing"))

```

### Create Imputed data (RQ1X) for family-level 

This imputation method won't impute for those with missing twins as we are missing their details in the wide format - so it just skips them! 

```{r}

df_rq5 = df %>%
  select(
    randomfamid,
    twin,
    rq1x, 
    starts_with("missing")
    ) %>%
  pivot_wider(
    id_cols = randomfamid,
    names_from = twin,
    values_from = c(atwmed1, starts_with("missing"))
  )

df_rightjoin = df %>%
  filter(twin == 1) %>%
  select(
    randomfamid,
    rq1x, 
    -atwmed1
    )
  
df_rq5 = left_join(df_rq5, df_rightjoin, by = "randomfamid")

where_matrix = is.na(df_rq5)
where_matrix[,str_detect(colnames(df_rq5),"^missing")] = FALSE

df_imputed_mice = mice(
  # select(df_rq5, -starts_with("missing")),
  df_rq5,
  method = "pmm", 
  where = where_matrix,
  m = 1,
  iter = 1
  )

df_imputed = mice::complete(
  df_imputed_mice, 
  action = 1 # just return the first imputed dataset
)

if (FALSE){
  df_imputed             %>% pull(afasoc2) %>% is.na() %>% table 
  df %>% filter(twin==1) %>% pull(afasoc2) %>% is.na() %>% table
    
  df_imputed$loggedEvents
  
  plot(df_imputed, layout = c(4,4))
  
  df_imputed %>%
    select(ends_with(c("_1", "_2"))) %>%
    sapply(., class)
}

df_imputed_long = df_imputed %>%
  mutate(across(ends_with(c("_1", "_2")), as.character)) %>%
  pivot_longer(
      cols = ends_with(c("_1", "_2")),
      names_to = c("variable", "twin"),
      names_sep = "_",
      values_to = "value"
  ) %>%
  pivot_wider(
      id_cols = !matches("variable|value"),
      names_from = variable,
      values_from = value
  ) %>%
  mutate(across(starts_with("missing"), as.factor)) %>%
  mutate(across(matches("twin|atwmed1"), ~ as.numeric(.)))

df_imputed_long = df_imputed_long %>%
  mutate(randomtwinid = as.numeric(paste0(randomfamid, twin))) %>%
  filter((.$randomtwinid %in% df$randomtwinid))


```

Tests

```{r}

test_that("Imputed data matches original data structure and values", { 
  x = df_imputed_long %>%
    mutate(randomtwinid = paste0(randomfamid, twin)) %>%
    # slice(match(df$randomtwinid, .$randomtwinid)) %>%
    mutate(across(everything(), ~as.character(.)))
  y = df %>%
    select(
      colnames(x)
    ) %>%
    mutate(across(everything(), ~as.character(.)))
  
  x[is.na(y)] = NA
  y[is.na(x)] = NA

  testthat::expect_equal(x,y, info = "Data do not match")
  
  x = df_imputed_long %>%
    sapply(., class)
  y = df %>%
    select(
      colnames(df_imputed_long)
    ) %>%
    sapply(., class)
  
  testthat::expect_equal(x,y, info = "Variable classes do not match")
  
  x = as.numeric(df_imputed_long$randomtwinid)
  y = as.numeric(df$randomtwinid)
  
  testthat::expect_equal(x,y, info = "randomtwinids match")

})



```

Check convergence

```{r}

3+3

```



```{r}

twinmodels = list()

for (i in seq_along(missingcode)){
  
  cat(i, "/", length(missingcode),"\n")
  formula <- as.formula(paste(missingcode[i], "~", paste(rq1x, collapse = "+")))
  twinmodels[[i]] = glm(formula, data = df_imputed_long, family = binomial,na.action = na.exclude)
  
  prediction = predict(twinmodels[[i]], type = "response", na.action = na.exclude)
  
  
  if (length(prediction)!=nrow(df_imputed_long)) stop("error")
  
  df[[paste0("prediction",i)]] = prediction
  df[[paste0("weight",i)]] = 1 / prediction
  
  # V_CR = clubSandwich::vcovCR(twinmodels[[i]], cluster = twinmodels[[i]]$data$famid, type = "CR2")
  # 
  # clubSandwich::coef_test(twinmodels[[i]], vcov = V_CR, test = "z")
  
}



```

# plots of predictions

Using cowplot i could arrange the histogram of all participation weights into the 

```{r}

df %>%
  select(starts_with("prediction")) %>%
  mutate(across(everything(), ~ qlogis(.))) %>%
  data.frame() %>%
  `colnames<-`((vars)) %>%
  gbtoolbox::plot_correlations(
    confidence_interval = FALSE,
    sample_size = FALSE,
    cluster_variables = TRUE
  ) + 
  labs(
    subtitle = "Correlation between twin's predicted non-missingness in each variable"
  )


df %>%
  select(starts_with("prediction")) %>%
  `colnames<-`(vars) %>%
  pivot_longer(cols = everything()) %>%
  ggplot(aes( x = value)) + 
  geom_histogram() + 
  xlim(0:1) + 
  facet_wrap(~name) + 
  labs(
    subtitle = "Histogram of all missinging probabilities"
  )

df %>%
  select(starts_with("weight")) %>%
  `colnames<-`(vars) %>%
  pivot_longer(cols = everything()) %>%
  ggplot(aes( x = value)) +
  geom_histogram(binwidth = 1) +
  # xlim(0:1) +
  coord_cartesian(xlim = c(0,25)) +
  facet_wrap(~name) +
  geom_vline(xintercept = 10, col = "red") + 
  labs(
    subtitle = "Histogram of all weights",
  )

df %>%
  select(starts_with("weight")) %>%
  `colnames<-`(vars) %>%
  pivot_longer(cols = everything()) %>%
  ggplot(aes( x = value)) + 
  geom_histogram(bins = 1000) + 
  # xlim(0:1) + 
  # facet_wrap(~name) + 
  labs(
    subtitle = "Histogram of all weights (grouped)"
  )


# # 
# histogram_plots = df %>%
#   select(starts_with("prediction")) %>%
#   `colnames<-`(vars) %>%
#   imap(~ ggplot(data.frame(value = .x), aes(x = value)) +
#          geom_histogram() +
#          xlim(0, 1) +
#          ggtitle(.y) +
#          theme_minimal())


```

Analysis code

```{r}

vars

rq5y_index   = match(paste0(rq5y,"-",rq5y),vars)
rq5y_weights = paste0("weight",rq5y_index) # Variable to indicate the respective univariate weight for each variable in rq5y 


sd          = sapply(rq5y,            function(var)   sd(df[[var]], na.rm = TRUE))
sd_weighted = sapply(seq_along(rq5y),
                         function(i) {
                           x = as.numeric(df[[rq5y[i]]])
                           w = df[[rq5y_weights[i]]]
                           complete_cases = complete.cases(x, w)

                           if (sum(complete_cases) == 0) NA else
                             Hmisc::wtd.var(x[complete_cases], w[complete_cases])^.5
                         })

means_unweighted = sapply(rq5y,            function(var) mean(df[[var]], na.rm = TRUE))
means_weighted   = sapply(seq_along(rq5y),
                         function(i) {
                           x = as.numeric(df[[rq5y[i]]])
                           w = df[[rq5y_weights[i]]]
                           complete_cases = complete.cases(x, w)

                           if (sum(complete_cases) == 0) NA else
                             stats::weighted.mean(x[complete_cases], w[complete_cases])
                         })

correlations_unweighted = sapply(seq_along(vars), function(i) cor(df[[x_var[i]]], df[[y_var[i]]], use = "pairwise.complete.obs"))
correlations_weighted   = sapply(seq_along(vars),
                         function(i) {
                           x = as.numeric(df[[x_var[i]]])
                           y = as.numeric(df[[y_var[i]]])
                           w = df[[paste0("weight",i)]]
                           complete_cases = complete.cases(x, y, w)

                           if (sum(complete_cases) == 0) NA else
                             weights::wtd.cors(x[complete_cases],y[complete_cases], w[complete_cases])
                         })
smd = (means_weighted - means_unweighted)/sd


data.frame(
  correlations_unweighted, correlations_weighted, diff = correlations_weighted-correlations_unweighted
) %>%
 knitr::kable(digits = 3)

```


