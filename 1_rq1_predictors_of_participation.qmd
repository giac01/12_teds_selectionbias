---
title: "RQ1: Y2 predictors of attrition"
format: 
  html:
    embed-resources: true
    fig-width: 8
    fig-height: 8
    code-link: true
    code-fold: true
    code-tools: true
    df-print: paged
    toc: true
    grid:
      body-width: 900px
editor: source
---

# Load Data

```{r}
#| output: false

source("0_load_data.R")

options(width = 900)

```

## List of variables

```{r}

data.frame(
  var = c(rq1x, rq1y, rq1y_twin),
  labels = c(rq1x_labels, rq1y_labels, rq1y_twin_labels),
  clean_labels = c(rq1x_labels_clean, rq1y_labels_clean, rq1y_twin_labels)
)


```

## Impute Missing Predictor Data

### Create Imputed data for family-level 

```{r}

daddy_issues = df_rq1 %>%
  select(adadagetw, afasoc2, afahqual)

df_rq1_imputed = df_rq1 %>%
  # select(-adadagetw, -afasoc2, -afahqual) %>% # removing these eliminates imputation warnings
  mice(method = "pmm", m =1)

df_rq1_imputed$loggedEvents

df_rq1_imputed = complete(df_rq1_imputed)

vars_to_na = c("btwdata","ctwdata", "gcdata","icdata","jcdata","pcwebdata")

df_rq1_imputed = df_rq1_imputed %>%
  mutate(
      across(starts_with(vars_to_na), ~ ifelse(cohort %in% c("Cohort 3: twins born Sep-95 to Aug-96","Cohort 4: twins born Sep-96 to Dec-96"), NA, .))
    )

# df_rq1_imputed$gcdata1 %>% table(., useNA = "always")

```


### Create Long Imputed dataset for twin-level analyses

For imputation, because predictor variables are only measured at the family level, imputation is performed in the wide format with one row per family. 

For modelling twin-level outcomes with glm(), we need to convert outcomes to a long format with one row per twin. 

```{r}

df_rq1_imputed$famid = 1:nrow(df_rq1_imputed)

df1 = df_rq1_imputed[c("famid", rq1x, rq1y_twin1)]
df2 = df_rq1_imputed[c("famid", rq1x, rq1y_twin2)]

  # Rename twin2 columns to match twin1 column names
colnames(df2) = colnames(df1)

df_rq1_long = rbind(df1, df2) %>%
  arrange(famid)

rm(df1, df2)

# Set outcome to missing for participants ineligible at specific time points


df_rq1_long$btwdata1 %>% table(., useNA = "always")

df_rq1_long %>% sapply(., function(x) length(which(is.na(x))))


```

## Correlation of participation over time

```{r}

df %>%
  filter(twin == 1) %>%
  select(starts_with(rq1y_twin)) %>% 
  select(matches("1$|2$")) %>%
  rename_with(.fn = function(x) var_to_label(x, twinsuffix = TRUE)) %>%
  rename_with(.fn = function(x) gsub(", 1Y 0N","",x)) %>%
  gbtoolbox::plot_correlations(
    sample_size = FALSE,
    confidence_interval = FALSE
  )

# sapply(rq1y_twin, function(var_x)
# calc_ace(data = df, var = var_x))

df %>% 
  select(randomfamid,twin,all_of(rq1y)) %>% 
  filter(twin == 1) %>%
  select(-twin, -randomfamid) %>% 
  `colnames<-`(c(rq1y_labels)) %>%
  gbtoolbox::plot_correlations(
    sample_size = FALSE,
    confidence_interval = FALSE
  ) + 
  labs(
    title = "Correlation between participation at different \ntime points",
    subtitle = "N = 13020 (Number of families)"
    )

save_plot("1_correlation_participation", width = 9, height = 9)

```

## List of predictor variables 

```{r}

cbind(rq1x, rq1x_labels) %>%
  knitr::kable()

```

## List of outcome variables

```{r}

cbind(rq1y, rq1y_labels) %>%
  knitr::kable()

```



# Twin-Level Logistic Regressions on each outcome

## Fit Models

Fit logistic regression models to each participation outcome

```{r}

twinmodels = list()

for (i in seq_along(rq1y_twin)){
  cat(i, "/", length(rq1y_twin),"\n")
  formula <- as.formula(paste(rq1y_twin1[i], "~", paste(rq1x, collapse = "+")))
  twinmodels[[i]] = glm(formula, data = df_rq1_long, family = binomial, na.action = na.omit)
  # V_CR = clubSandwich::vcovCR(twinmodels[[i]], cluster = twinmodels[[i]]$data$famid, type = "CR2")

  # clubSandwich::coef_test(twinmodels[[i]], vcov = V_CR, test = "z")
  
}


```



## Compare model predictions for each participant

To get standard errors for our predictions... we will need to so something a bit more complex. 

I've removed the intercept from predictions

** Predictions for participants at cohorts 3-4 at specific timepoints are kept in here!! **



```{r}

twinmodels_predictions = list()

for (i in seq_along(rq1y_twin)){
  twinmodels_predictions[[i]] = twinmodels[[i]]$data 
  
  twinmodels_predictions[[i]]$prediction = twinmodels[[i]] %>% 
    predict(
      ., 
      newdata = df_rq1_long,
      type = "link", 
      na.action = na.pass,
    ) - twinmodels[[i]]$coefficients[1] # removed intercept term
  
}
names(twinmodels_predictions) = rq1y_twin

twinmodels_predictions = bind_rows(twinmodels_predictions, .id = "outcome")

twinmodels_predictions %>% 
  select(famid, outcome, prediction) %>% 
  mutate(
    outcome = rq1y_twin_labels_clean_extrashort[match(.$outcome, rq1y_twin)]
  ) %>%
  group_by(outcome) %>%
  filter(!duplicated(famid)) %>%
  pivot_wider(
    values_from = "prediction",
    names_from  = "outcome",
    id_cols     = "famid"
  ) %>%
  data.frame() %>%
  select(-famid) %>%
  gbtoolbox::plot_correlations(
    sample_size = FALSE
  ) + 
  labs(
    subtitle = "Correlation between predicted probability (type = link) across outcomes"
  )

save_plot("1_rq1_predicted_probability_plots", width = 8, height = 8)


```

## Significance of individual variables

A detailed version of the figure below can be found here [here](plots/1_rq1_variable_importance.pdf){target="_blank"}.

```{r}
#| echo: false
 # debug(glm_model_comparison_robust)
 # system.time({
 # test = twinmodels[[11]] %>% glm_model_comparison_robust
 # })
# test0 = twinmodels[[11]] %>% glm_model_comparison_robust
# glm_model_comparison_results = lapply(twinmodels, glm_model_comparison_robust)

glm_model_comparison_results = parallel::mclapply(twinmodels, glm_model_comparison_robust, mc.cores = 8)

glm_model_comparison_results_df = do.call("rbind.data.frame", glm_model_comparison_results)

glm_model_comparison_results_df$Variables_full = rq1x_labels_clean[match(glm_model_comparison_results_df$Variables_Dropped, rq1x)]

# Adjust p-values and add star

glm_model_comparison_results_df = glm_model_comparison_results_df %>% 
  filter(Variables_Dropped!="None") %>%
  group_by(outcome) %>%
  mutate(Wald_p = stats::p.adjust(Wald_p, method = "holm")) %>% 
  ungroup() %>%
  mutate(
    Wald_p_star = as.character(symnum(Wald_p, cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1), symbols = c("***", "**", "*", ".", " ")))
  )

variable_importance_order = glm_model_comparison_results_df %>%
  group_by(Variables_full) %>%
  summarise(mean_score = mean(Wald_p)) %>%
  arrange(mean_score) %>%
  pull(Variables_full)

glm_model_comparison_results_df = glm_model_comparison_results_df %>%
  mutate(
    Variables_full = factor(Variables_full, levels = variable_importance_order),
    var_outcome = paste(Variables_Dropped, outcome, sep = "_")
  )

# Plotting code
glm_model_comparison_results_df %>%
  mutate(
    outcome_labeled = rq1y_twin_labels_clean[match(.$outcome,rq1y_twin1)],
    outcome_labeled = factor(outcome_labeled, levels = rq1y_twin_labels_clean),
    # outcome_labeled = outcome_labeled %>% str_remove("data.*"),
    # outcome_labeled = factor(outcome_labeled, levels =  str_remove(var_to_label(rq1y),"data.*")),
    criterion       = Delta_AUC,
    sig_level = case_when(
      Wald_p < 0.001 ~ "p < 0.001",
      Wald_p < 0.01 ~ "p < 0.01", 
      Wald_p < 0.05 ~ "p < 0.05",
      Wald_p < 0.1 ~ "p < 0.1",
      TRUE ~ "Not significant"
    ),
    sig_level = factor(sig_level, levels = c("p < 0.001", "p < 0.01", "p < 0.05", "p < 0.1", "Not significant"))
  ) %>%
  # Clean the delta_AUC variable that gets printed on the plots 
  mutate(
    criterion2 = gsub("0\\.", ".", sprintf("%.3f", criterion)),
    criterion2 =  case_when(
      Wald_p < 0.001 ~ paste0(criterion2,"***"),
      Wald_p < 0.01 ~ paste0(criterion2,"***"),
      Wald_p <= 0.05 ~ paste0(criterion2,"***"),
      Wald_p > 0.05 ~ paste0(criterion2)
    ),
  ) %>%
  ggplot(aes(y = Variables_full, x = criterion)) + 
  geom_col(aes(fill = sig_level), alpha = 0.8) + 
  geom_text(aes(label = criterion2),  # Remove ALL 0. patterns
            size = 2.5, fontface = "bold", color = "black") +
  facet_wrap(~outcome_labeled, scales = "fixed", ncol = 6) +
  scale_x_continuous(labels = function(x) gsub("0\\.", ".", sprintf("%.3f", x))) +  # Remove ALL 0. patterns
  scale_fill_manual(
    values = c("p < 0.001" = "#d73027", "p < 0.01" = "#fc8d59", 
               "p < 0.05" = "#fee08b", "p < 0.1" = "#e0f3f8", 
               "Not significant" = "#d9d9d9"),
    name = "Significance\n(Holm-adjusted)"
  ) +
  labs(
    x = "Change in AUC (when variable removed)",
    y = NULL,
    title = "Variable Importance by AUC Change",
    subtitle = "Colors show Holm-adjusted significance levels"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 7),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    strip.text = element_text(size = 9, face = "bold"),
    legend.position = "bottom"
  )

save_plot("1_rq1_variable_importance_twin-level", width = 14, height = 7)

```



#### Calc variable importance for plotting

```{r}
variable_importance = glm_model_comparison_results_df %>%
  filter(Variables_Dropped != "None") %>%
  group_by(Variables_full) %>%
  summarise(
    n_significant_05 = sum(Wald_p < 0.05, na.rm = TRUE),
    avg_delta_auc = mean(pmax(0, Delta_AUC * -10000), na.rm = TRUE),
    avg_p_value = mean(Wald_p, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(n_significant_05)) %>%
  mutate(importance_rank = row_number())
```


#### Circular Barplot

```{r}

library(ggplot2)
library(dplyr)
library(stringr)

# Prepare data - first calculate importance order by number of significant results

circular_data = glm_model_comparison_results_df %>%
  filter(Variables_Dropped != "None") %>%
  filter(outcome %in% rq1y_twin1[6:15]) %>%
  mutate(
    outcome_labeled = rq1y_twin_labels_clean[match(outcome, rq1y_twin1)],
    Delta_AUC_scaled = pmax(0, Delta_AUC * -10000),  # Multiply by -1 and set negatives to 0
    Variables_wrapped = str_wrap(Variables_full, width = 8)
  ) %>%
  # Join with importance ranking
  left_join(variable_importance, by = "Variables_full") %>%
  # Create position for grouping by variable (ordered by importance)
  group_by(importance_rank) %>%
  mutate(
    variable_order = importance_rank,
    outcome_within_var = row_number(),
    n_outcomes = dplyr::n()
  ) %>%
  ungroup() %>%
  mutate(
    # Create x position: variable position + small offset for each outcome within variable
    x_pos = variable_order + (outcome_within_var - 1) * 0.8 / n_outcomes - 0.4
  )

# Create segment boundary data
n_vars = length(unique(circular_data$Variables_full))
segment_lines = data.frame(
  x = seq(0.5, n_vars + 0.5, by = 1),
  y_max = max(circular_data$Delta_AUC_scaled) * 1.1
)

# Create circular barplot
ggplot(circular_data) +
  geom_hline(
    aes(yintercept = y), 
    data.frame(y = seq(0, max(circular_data$Delta_AUC_scaled), length.out = 4)),
    color = "lightgrey", size = 0.3
  ) + 
  # Add segment lines
  geom_segment(
    data = segment_lines,
    aes(x = x, y = 0, xend = x, yend = y_max),
    color = "gray70", size = 0.5, alpha = 0.7
  ) +
  geom_col(
    aes(
      x = x_pos,
      y = Delta_AUC_scaled,
      fill = outcome_labeled
    ),
    alpha = 0.8, width = 0.8 / max(circular_data$n_outcomes)
  ) +
  # Add variable labels at outer edge
  geom_text(
    data = circular_data %>% distinct(Variables_full, variable_order, Variables_wrapped),
    aes(
      x = variable_order,
      y = max(circular_data$Delta_AUC_scaled) * 1.15,
      label = Variables_wrapped
    ),
    size = 2.5, hjust = 0.5
  ) +
  coord_polar() +
  scale_y_continuous(
    limits = c(0, max(circular_data$Delta_AUC_scaled) * 1.3),
    expand = c(0, 0),
    breaks = seq(0, max(circular_data$Delta_AUC_scaled), length.out = 4),
    labels = function(x) sprintf("%.1f", x)
  ) + 
  scale_fill_viridis_d(guide = "none") +
  labs(
    title = "Variable Importance by Outcome",
    y = "Delta AUC (×10000)"
  ) +
  theme_minimal() +
  theme(
    axis.title.x = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 8, color = "gray50"),
    panel.background = element_rect(fill = "white", color = "white"),
    panel.grid = element_blank()
  )

```

#### Cricular Heatmap


```{r}
rq1y_twin_labels_clean_extrashort2 = paste0(rq1y_twin_labels_clean_extrashort, " ")

# Alternative circular heatmap approach
heatmap_data = glm_model_comparison_results_df %>%
  filter(Variables_Dropped != "None") %>%
  mutate(
    outcome_labeled = rq1y_twin_labels_clean_extrashort2[match(outcome, rq1y_twin1)],
    outcome_labeled = factor(outcome_labeled, levels = rq1y_twin_labels_clean_extrashort2),
    Variables_wrapped = str_wrap(Variables_full, width = 8),
    # Set Delta_AUC to NA if not significant, otherwise keep original negative value
    # Set to grey for specific variables
    Delta_AUC_fill = case_when(
      Wald_p < 0.05 ~ abs(Delta_AUC),
      TRUE ~ NA
    )
  ) %>%
  # Join with importance ranking from above
  left_join(variable_importance, by = "Variables_full") %>%
  mutate(
    # Set factor levels based on importance ranking
    Variables_wrapped = factor(Variables_wrapped, 
                              levels = unique(Variables_wrapped[order(importance_rank)]))
  )

# Add empty variables to create gap
n_vars = length(levels(heatmap_data$Variables_wrapped))
all_vars = c(levels(heatmap_data$Variables_wrapped))

heatmap_data$Variables_wrapped = factor(heatmap_data$Variables_wrapped, levels = all_vars)

# # Create custom y-axis labels in the gap
# n_outcomes = length(levels(heatmap_data$outcome_labeled))
# gap_middle = length(levels(heatmap_data$Variables_wrapped)) - 1.5  # Center of the gap

# y_labels_data = data.frame(
#   x = 0.01,
#   y = seq_along(levels(heatmap_data$outcome_labeled)),  # Match tile positions exactly
#   label = levels(heatmap_data$outcome_labeled)
# )

ggplot(heatmap_data, aes(x = Variables_wrapped, y = outcome_labeled)) +
  geom_tile(aes(fill = Delta_AUC_fill, 
                color = ifelse(Variables_Dropped %in% c("astress", "atwmed1", "pollution1998pca", "adrink", "adadagetw"), "azure2", "black")), 
            size = .5) +
  scale_color_identity() +
  geom_text(
    aes(label = ifelse(Wald_p < 0.05, 
                       gsub("^(-?)0\\.", "\\1.", sprintf("%.3f", Delta_AUC)), ""),
        size = ifelse(outcome_labeled %in% c("Y2","Y3"), 1.2, 2.4)
    ), 
    color = "white"
  ) +
  scale_size_identity() +
  # Add custom y-axis labels in the gap
  coord_polar(theta = "x", start = 0, direction = 1) +
  # scale_x_discrete(drop = FALSE, labels = function(x) ifelse(grepl("GAP_", x), "", x)) +  # Hide GAP labels
  scale_fill_gradient(
    na.value = "white",
    low = "#f48c84", 
    high = "#d73027",
    limits = c(0, max(heatmap_data$Delta_AUC_fill, na.rm = TRUE)),
    guide = "none"
  ) +
  labs(
    tag = "B",
    title = "Variable Importance Heatmap",
    subtitle = "Values indicate change in AUC when variable is removed;\n colors indicate statistical significance"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, size = 11),
    axis.text.y = element_blank(),  # Hide default y-axis labels
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.tag = element_text(hjust = 0, vjust = 0, size = 30, face = "bold"),
    plot.tag.position = "topleft",
    plot.title = element_text(hjust = 0.5, size = 16),
    plot.subtitle = element_text(hjust = 0.5, size = 13.5, margin = margin(b = 0))
  ) +
  {
    y_positions = seq_along(levels(heatmap_data$outcome_labeled))
    labels = levels(heatmap_data$outcome_labeled)
    
    lapply(seq_along(labels), function(i) {
      annotate("text", x = 0.5, y = y_positions[i],
               label = labels[i], size = 2.8, hjust = 1, angle = 7)
    })
  }


save_plot("1_rq1_heatmap_twinparticipationpredictors", width = 8, height = 8)

```

### AUC and Variance Explained Plots

```{r}

model_metrics = do.call("rbind.data.frame", glm_model_comparison_results) %>%
  filter(Variables_full=="None") %>%
  select(-contains("Delta"),-contains("Wald")) %>%
  mutate(
    outcome = rq1y_twin_labels_clean_extrashort[match(.$outcome, rq1y_twin1)],
    outcome = factor(outcome, levels = rq1y_twin_labels_clean_extrashort)
  ) 

model_metrics

plot_data = model_metrics %>%
  select(outcome, AUC, mcfad_r2) %>%
  mutate(
    AUC_scaled = -(AUC - 0.5),
    R2_scaled = mcfad_r2 * 2.6
  ) %>%
  pivot_longer(cols = c(AUC_scaled, R2_scaled), names_to = "metric", values_to = "value_scaled") %>%
  mutate(
    metric_label = case_when(
      metric == "AUC_scaled" ~ "AUC",
      metric == "R2_scaled" ~ "McFadden's R²"
    ),
    original_value = ifelse(metric == "AUC_scaled", AUC, mcfad_r2),
    label_value    = case_when(
      metric == "AUC_scaled" ~ gbtoolbox::apa_num(original_value,3),
      metric == "R2_scaled" ~ paste0(gbtoolbox::apa_num(original_value*100,2),"%")
    )
  )

ggplot(plot_data, aes(y = outcome, x = value_scaled, fill = metric_label)) +
  geom_col(width = 0.7, alpha = 0.8) +
  geom_text(aes(label = label_value), 
            hjust = ifelse(plot_data$metric == "AUC_scaled", 1.1, -0.1),
            size = 2.5) +
  scale_fill_manual(values = c("AUC" = "#5e3c99", "McFadden's R²" = "#e66101")) +
  labs(
    tag = "A",
    title = "Participation Prediction Accuracy",
    # subtitle = "Accuracy in predicting \nparticipation at each Time Point",
    x = NULL,
    y = NULL,
    fill = NULL
  ) +
  theme_minimal() +
  coord_cartesian(clip = "off") +
  theme(
    legend.position = "bottom",
    axis.text.y = element_text(size = 10.5, angle = 0, margin = margin(r = 10, unit = "pt"), color = "black"),
    # panel.grid.major.x = element_line(color = "grey90"),
    panel.grid = element_blank(),
    plot.margin = margin(t = 20, r = 20, b = 50, l = 20, unit = "pt"),
    axis.text.x = element_blank(),
    plot.tag = element_text(hjust = 0, vjust = 0, size = 30, face = "bold"),
    plot.tag.position = "topleft",
    plot.title = element_text(hjust = 0.5, size = 16)
  ) +
  geom_vline(xintercept = 0, color = "black", size = 0.5)


save_plot("1_rq1_twinlevel_prediction_accuracy", width = 5, height = 8)

```


### Twin-Level Logistic Regression Coefficients

```{r}

# Extract all coefficients from twin models and combine
twinmodels_results0 = do.call(rbind, lapply(1:length(twinmodels), function(i) {
    vcov_robust = clubSandwich::vcovCR(twinmodels[[i]], 
                                    cluster = twinmodels[[i]]$data$famid, 
                                    type = "CR2") 
    coefs       = clubSandwich::conf_int(twinmodels[[i]], vcov = vcov_robust, test = "naive-tp")

    coefs$outcome = rq1y_twin1[i] 
  return(coefs)
}))

twinmodels_results = twinmodels_results0 %>%
  data.frame() %>%
  dplyr::rename(term = "Coef") %>%
  `rownames<-`(NULL)


# # Extract all coefficients from twin models and combine
# twinmodels_results = do.call(rbind, lapply(1:length(twinmodels), function(i) {
#   coefs = broom::tidy(twinmodels[[i]], conf.int = FALSE) %>%
#     select(-std.error, -statistic, -p.value)
#   coefs$outcome = rq1y_twin1[i]
#   return(coefs)
# }))

twinmodels_results$var = str_extract(twinmodels_results$term, paste0("^(", paste(rq1x, collapse = "|"), ")"))
twinmodels_results$var[twinmodels_results0$Coef == "(Intercept)"] = "Intercept"
twinmodels_results$var_outcome = paste(twinmodels_results$var,twinmodels_results$outcome, sep = "_")
# Bonferonni-holm corrected p-value
twinmodels_results$Wald_p = glm_model_comparison_results_df$Wald_p[match(twinmodels_results$var_outcome,glm_model_comparison_results_df$var_outcome)]

twinmodels_results %>%
    mutate(
      outcome = rq1y_twin_labels_clean_extrashort[match(.$outcome, rq1y_twin1)],
      term = case_when(
        term == "(Intercept)" ~ "Intercept",
        term == "sex1" ~ "Twin Sex (Male)",
        term == "amumagetw" ~ "Mother age at birth",
        term == "adadagetw" ~ "Father age at birth",
        term == "aadultscohabiting biological parent with other" ~ "Household Type: Cohabiting parent",
        term == "aadultssingle parent" ~ "Household Type: Single parent",
        term == "zygos2" ~ "Zygosity (DZ)",
        term == "amedtot" ~ "Mother medical risk",
        str_starts(term, "afasoc2") & str_detect(term, "^afasoc2\\d$") ~ paste0("Father employment: Level ", str_sub(term, -1)),
        term == "afasoc2caring for children at home" ~ "Father employment: Caring for children",
        term == "afasoc2no job" ~ "Father employment: No job",
        term == "afahqualno qualifications" ~ "Father education: No qualifications",
        term == "afahqualCSE grade 2-5 or O-level/GCSE grade D-G" ~ "Father education: CSE/GCSE D-G",
        term == "afahqualA-level or S-level" ~ "Father education: A-level",
        term == "afahqualHNC" ~ "Father education: HNC",
        term == "afahqualHND" ~ "Father education: HND",
        term == "afahqualundergraduate degree" ~ "Father education: Undergraduate",
        term == "afahqualpostgraduate qualification" ~ "Father education: Postgraduate",
        str_starts(term, "amosoc2") & str_detect(term, "^amosoc2\\d$") ~ paste0("Mother employment: Level ", str_sub(term, -1)),
        term == "amosoc2no job" ~ "Mother employment: No job",
        term == "amohqualCSE grade 2-5 or O-level/GCSE grade D-G" ~ "Mother education: CSE/GCSE D-G",
        term == "amohqualCSE grade 1 or O-level/GCSE grade A-C" ~ "Mother education: CSE/GCSE A-C",
        term == "amohqualA-level or S-level" ~ "Mother education: A-level",
        term == "amohqualHNC" ~ "Mother education: HNC",
        term == "amohqualHND" ~ "Mother education: HND",
        term == "amohqualundergraduate degree" ~ "Mother education: Undergraduate",
        term == "amohqualpostgraduate qualification" ~ "Mother education: Postgraduate",
        term == "atwmed1" ~ "Twin medical risk",
        term == "aethniccAsian" ~ "Ethnic origin: Asian",
        term == "aethniccBlack" ~ "Ethnic origin: Black",
        term == "aethniccMixed race" ~ "Ethnic origin: Mixed race",
        term == "aethniccOther" ~ "Ethnic origin: Other",
        term == "alangEnglish" ~ "Language: English only",
        term == "alangEnglish + other" ~ "Language: English + other",
        str_starts(term, "anoldsib") & str_detect(term, "\\d+$") ~ paste0("Older siblings: ", str_extract(term, "\\d+")),
        term == "anoldsib5 or more" ~ "Older siblings: 5+",
        term == "anyngsib1" ~ "Younger siblings: 1",
        term == "anyngsib2 or more" ~ "Younger siblings: 2+",
        term == "atwclub1" ~ "Twins club member",
        term == "alookels1" ~ "Childcare by others",
        term == "asmoke1" ~ "Smoking in pregnancy",
        term == "adrink1" ~ "Alcohol in pregnancy",
        term == "astress1" ~ "Severe stress in pregnancy",
        term == "cens01pop98density" ~ "Population density",
        term == "pollution1998pca" ~ "Pollution index",
        TRUE ~ term
      )
    ) %>%
  mutate(
    beta = gbtoolbox::apa_num(beta, n_decimal_places = 3),
    CI_L = gbtoolbox::apa_num(CI_L, n_decimal_places = 3),
    CI_U = gbtoolbox::apa_num(CI_U, n_decimal_places = 3),
    SE   = gbtoolbox::apa_num(SE,   n_decimal_places = 3),
    Wald_p_clean = gbtoolbox::apa_num(Wald_p, n_decimal_places = 3),

    table_val = paste0(beta,"\n[",CI_L,",\n",CI_U,"]\np=",Wald_p_clean,"\nSE=", SE = SE)
  ) %>%
  select(term, table_val, Wald_p, outcome) %>%
  pivot_wider(
    id_cols = term,
    values_from = c("table_val", "Wald_p"),
    names_from = outcome
  ) %>%
  gt() %>%
  tab_style(
    style = cell_text(whitespace = "pre-wrap"),
    locations = cells_body(columns = starts_with("table_val"))
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y2", rows = Wald_p_Y2 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y3", rows = Wald_p_Y3 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y4", rows = Wald_p_Y4 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y7", rows = Wald_p_Y7 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y9", rows = Wald_p_Y9 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y10", rows = Wald_p_Y10 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y12 (web test)", rows = `Wald_p_Y12 (web test)` < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y12 (q'aire)", rows = `Wald_p_Y12 (q'aire)` < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y16 (web)", rows = `Wald_p_Y16 (web)` < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y16 (q'aire)", rows = `Wald_p_Y16 (q'aire)` < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y18", rows = Wald_p_Y18 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y21", rows = Wald_p_Y21 < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y26 (q'aire)", rows = `Wald_p_Y26 (q'aire)` < 0.05)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d5e8d4"),
    locations = cells_body(columns = "table_val_Y26 (web test)", rows = `Wald_p_Y26 (web test)` < 0.05)
  ) %>%
  cols_hide(columns = starts_with("Wald_p")) %>%
  cols_label_with(
    fn = function(x) str_remove(x, "table_val_")
  ) %>%
  tab_options(
      table.width = "50%",
      table.font.size = "8px"
    ) %>%
      cols_width(
      term ~ px(65),
      starts_with("table_val") ~ px(40)
    ) %>%
  tab_source_note(
    source_note = "Note: Confidence intervals calculated using cluster robust standard errors clustered by family, calculated using the clubSandwich R package with CR2 (bias-reduced linearization) adjustment and naive-tp small sample adjustment. Cluster robust Wald tests were used to calculate using the ClubSandwich R package. Note that for dummy variables, Wald tests were performed by constraining all dummy variables in a given set to zero - therefore dummy variables derived from the same categorical variable have the same p-values."
  ) 



```


## Plot Marginal Effects of maternal education

```{r}

library(marginaleffects)

# Calculate average predictions for maternal education variables

# Calculate predictions for all models
all_predictions = map_dfr(1:length(twinmodels), function(i) {
  data_grid = datagrid(
    model = twinmodels[[i]],
    amohqual = unique
  )
  
  predictions(
    twinmodels[[i]],
    newdata = data_grid,
    type = "response"
  ) %>% 
    data.frame() %>%
    mutate(
      outcome = rq1y_twin_labels_clean_extrashort[i],
      amohqual = factor(amohqual, levels = levels(df$amohqual))
    )
})

# Plot all predictions together
all_predictions %>%
  mutate(
    outcome = factor(outcome, levels = rq1y_twin_labels_clean_extrashort)
  ) %>%
  ggplot(aes(x = amohqual, y = estimate, group = outcome, color = outcome)) + 
  geom_point() + 
  geom_line() + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Predicted Participation by Maternal Education Level",
    subtitle = "Across all study timepoints",
    x = "Maternal Education Level",
    y = "Predicted Probability",
    color = "Study Wave",
    caption = "Note: Predictions calculated using logistic regression models fitted separately for each study wave.\nAll other covariates held at their observed means (continuous) or modes (categorical).\nPredictions computed using the marginaleffects R package."
  )

```



# Descriptive Information

Total number of families in dataset: `r length(unique(df0$randomfamid))`

Total number of families with no predictor information (and are just completely removed from the analysis): `r length(which(apply(df[rq1x], 1, function(x) length(which(!is.na(x))))==0))`

## Participation rates at each timepoint

```{r}

df_rq1y %>%
  sapply(., function(x) length(which(x==1))/length(which(x>=0)))

df_rq1y %>%
  mutate(across(everything(), as.character)) %>%
  # rename_from_labels() %>%
  pivot_longer(cols = everything()) %>%
  group_by(name) %>%
  count(value) %>%
  # mutate(name_count = n()) %>%
  # filter(name_count < 10) %>%
  # select(-name_count) %>%
  knitr::kable()

df_rq1y %>%
  # select(where(is.numeric)) %>%
  mutate(across(everything(), as.character)) %>%
  mutate(across(everything(), ~as.character(replace_na(., "NA")))) %>%
  pivot_longer(cols = everything()) %>%
  ggplot(aes(x=value)) +
  geom_bar() +
  facet_wrap(~name, ncol = 4, scales = "free")

```

## Predictor variables (rq1x)

### Distribution

```{r}

df_rq1x %>%
  select(!where(is.numeric)) %>%
  rename_from_labels() %>%
  mutate(across(everything(), as.character)) %>%
  pivot_longer(cols = everything()) %>%
  ggplot(aes(x=value)) +
  geom_bar() +
  facet_wrap(~name, ncol = 4, scales = "free") +
    theme(
    axis.text.x = element_text(
      angle = 20, 
      hjust = 1, 
      vjust = 1,     # Middle vertical alignment
      size = 8         # Adjust text size if needed
    ))


```

### Missingness

```{r}

df_rq1x %>%
  mutate(across(everything(), ~ as.numeric(!is.na(.)))) %>%
  pivot_longer(
    cols = everything()
  ) %>%
  group_by(name) %>%
  summarise(percent_notmissing = mean(value)) %>%
  knitr::kable()


```

## Missing Data Patterns

```{r}


df_rq1x %>%
  `colnames<-`((rq1x_labels)) %>%
  as_tibble() %>%
  ggmice::plot_pattern(., rotate = TRUE)

save_plot("1_rq1_misssing_data_pattern", width = 12, height = 30)

df_rq1_imputed %>%
  select(rq1x) %>%
  data.frame() %>%
  `colnames<-`((rq1x_labels)) %>%
  as_tibble() %>%
  ggmice::plot_pattern(., rotate = TRUE)

save_plot("1_rq1_misssing_data_pattern_imputed", width = 12, height = 30)

```

# Predicting missingness of SDQ/MFQ data

## Data Prep

1 = Not missing

[Note that at Yr16,](https://datadictionary.teds.ac.uk/studies/derived_variables/16yr_derived_variables.htm#pbhsdq) the emotion subtest was not administered to parents, so the conduct one is used instead.

```{r}
#| eval: true

list_of_sdq_var = c(
  # "bsdqcemot1", 
  # "csdqcemot1", 
  # "dsdqemot1", 
  # "gpsdqemot1", 
  # "icsdqemot1", "ipsdqemot1", 
  "lcsdqemot1", "lpsdqemot1", 
  "pcbhsdqemot1", "ppbhsdqcont1", 
  "u1csdqemot1", "ucv1sdqemot1", "u1psdqemot1", 
  "zmhsdqemot1"
)

rq1m = c(
  "lcsdqemot1", "lpsdqemot1", "lcmfqt1", "lpmfqt1",
  "pcbhsdqemot1", "ppbhsdqcont1", "pcbhmfqt1", "ppbhmfqt1", 
  "u1csdqemot1", "ucv1sdqemot1", "u1psdqemot1", "u1cmfqt1", "ucv1mfqt1", 
  
  "zmhsdqemot1", "zmhmfqt1"
)

rq1m_childmeasures = c(
  "lcsdqemot1", "lcmfqt1", 
  "pcbhsdqemot1", "pcbhmfqt1", 
  "u1csdqemot1", "ucv1sdqemot1",  "u1cmfqt1", "ucv1mfqt1", 
  "zmhsdqemot1", "zmhmfqt1"
)

rq1m_parentmeasures = c(
  "lpsdqemot1",  "lpmfqt1",
  "ppbhsdqcont1","ppbhmfqt1", 
  "u1psdqemot1"
)

missing_outcomes = df %>% 
  filter(acontact == 1) %>%
  select(all_of(rq1m)) %>%
  sapply(.,function(x) as.numeric(!is.na(x)))

# missing_outcomes = sapply(xx,function(x) as.numeric(is.na(x)))
```

## Descriptives

```{r}

data.frame(
  var = rq1m,
  labels = var_to_label(rq1m),
  p_notmissing = apply(missing_outcomes, 2, function(x) length(which(x==1))/length(x)*100) %>% round()
)

# Check how concordant missingness is between twins

df %>% 
  filter(acontact == 1) %>%
  select("randomfamid", "twin", all_of(rq1m)) %>%
  # rename_from_labels() %>%
  pivot_wider(id_cols = randomfamid, values_from = rq1m, names_from = twin) %>%
  mutate(
    across(
      ends_with("1") | ends_with("2"), 
      ~as.numeric(!is.na(.))
    )
  ) %>%
  select(-randomfamid) %>%
  gbtoolbox::plot_correlations(
    confidence_interval = FALSE,
    sample_size = FALSE
  )

df %>% 
  filter(acontact == 1) %>%
  select("randomfamid", "twin", all_of(rq1m_childmeasures)) %>%
  # rename_from_labels() %>%
  pivot_wider(id_cols = randomfamid, values_from = rq1m_childmeasures, names_from = twin) %>%
  mutate(
    across(
      ends_with("1") | ends_with("2"), 
      ~as.numeric(!is.na(.))
    )
  ) %>%
  gbtoolbox::plot_correlations(
    confidence_interval = FALSE,
    sample_size = FALSE
  ) + 
  labs(title = "Child Measures Only")



  # cor(., use = "pairwise.complete.obs") %>%
  # round(., 3)
  # 
  
  
cbind.data.frame(df)

```

